import React, {Component} from 'react';
import {Link} from 'react-router-dom';
import InfiniteScroll from 'react-infinite-scroller';
import { connect } from "react-redux";

import {TagList} from './Tag';

import queryString from "query-string";

import api from "@malwarefront/api";
import { encodeSearchQuery, decodeSearchQuery, escapeSearchValue } from "@malwarefront/helpers";
import { View } from "@malwarefront/ui";
import QuickQuery from "./QuickQuery"

export let ObjectTagRenderer = (
    props => <TagList tags={props.tags}
                      tagClick={(ev, tag) => { ev.preventDefault(); props.addToQuery("tag", tag) }}
                      tagRemove={(ev, tag) => props.addToQuery("NOT tag", tag)}
                      filterable={true}/>
);

export let ObjectQueryLink = (
    props => <a href="#query" onClick={(ev) => { ev.preventDefault(); props.addToQuery(props.queryKey, props.value)}}>{props.value}</a>
)

export function ObjectField(args) {
    let defaultStyle = {
        maxWidth: '350px',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        whiteSpace: 'nowrap',
        textAlign: 'left',
        wordBreak: 'break-all'
    };
    let component = (props) => <td style={args.style || defaultStyle}>{args.render(props)}</td>
    component.label = args.label
    return component
}


export class ObjectItem extends Component {
    static get labels() {
        return this.fields.map(f => f.label)
    }

    recentClass = function (date) {
        let delta = new Date() - new Date(date);
        if (delta < 24*60*60*1000)
            return "today";
        if (delta < 72*60*60*1000)
            return "recent";
        return "";
    };

    render() {
        return (
            <tr key={this.props.id} className={this.recentClass(this.props.upload_time)}>
                {this.constructor.fields.map((Field, idx) => <Field key={idx} {...this.props}/>)}
            </tr>
        );
    }
}


class RecentObjects extends Component {
    state = {
        error: null,
        queryError: null,
        elements: [],
        // Informs InfiniteScroll whether there are more elements to load 
        hasMore: true,
        // Indicates that InfiniteScroll is currently loading next page
        loadsMore: true,
        // Locks view when query has been changed and first results are not loaded yet
        lockView: false,
    }

    initialState() {
        return {
            error: null,
            queryError: null,
            elements: [],
            hasMore: true,
            loadsMore: false,
            lockView: false
        };
    }

    static getDerivedStateFromProps(nextProps, prevState) {
        // Derive query from props before InfiniteScroll is mounted
        let query = RecentObjects.getQueryFromProps(nextProps);
        if(query && prevState.currentQuery === undefined)
        {
            return {
                query: query,
                currentQuery: query
            }
        }
        return {}
    }

    static getQueryFromProps(props) {
        return decodeSearchQuery((queryString.parse(props.location.search)["q"] || "").trim())
    }

    componentDidUpdate = (prevProps, prevState) => {
        // Accept new query by resetting state
        let nextQuery = RecentObjects.getQueryFromProps(this.props)
        let prevQuery = RecentObjects.getQueryFromProps(prevProps);
        if(nextQuery !== prevQuery)
        {
            this.scroll.pageLoaded = 0;
            this.setState({
                ...this.initialState(),
                query: nextQuery,
                currentQuery: nextQuery
            });
        }
    };

    updateCurrentQuery = (q) => {
        this.props.history.push(`${this.props.location.pathname}?q=${q}`);
    }

    updateQueryValue = (evt) => {
        this.setState({query: evt.target.value})
    }

    handleQuerySubmit = (evt) => {
        if(evt) evt.preventDefault();
        this.submitQuery()
    }

    handleQueryReset = () => {
        this.submitQuery("");
    }

    transformHash = (query, dhashOnly) => {
        // SHA256
        if((/^[0-9a-fA-F]{64}$/g).test(query))
            if(dhashOnly)
                return `dhash:${query.toLowerCase()}`
            else
                return `sha256:${query.toLowerCase()}`
        // No SHA256 and dhashOnly? Time to stop
        if(dhashOnly)
            return query
        // SHA1
        if((/^[0-9a-fA-F]{40}$/g).test(query))
            return `sha1:${query.toLowerCase()}`
        // MD5
        if((/^[0-9a-fA-F]{32}$/g).test(query))
            return `md5:${query.toLowerCase()}`
        // SHA512
        if((/^[0-9a-fA-F]{128}$/g).test(query))
            return `sha512:${query.toLowerCase()}`
        return query
    }

    submitQuery = (query) => {
        if(query === undefined)
            query = this.state.query;
        query = this.transformHash(query, this.props.dhashOnly);
        // Preflight query
        this.setState({query, lockView: true}, async () => {
            let encodedQuery = this.state.query ? encodeSearchQuery(this.state.query) : "";
            try {
                await api.getObjectList(this.props.type, null, this.state.query)
                // If ok - load more pages
                this.updateCurrentQuery(encodedQuery);
            } catch(error) {
                if(error.response && error.response.status === 404)
                {
                    // If there are no elements: reset state to blank
                    this.scroll.pageLoaded = 0;
                    this.setState(this.initialState());
                    return
                }
                this.setState({queryError: error})
            } finally {
                this.setState({lockView: false});
            }
        })
    }


    addToQuery = (field, value) => {
        const OP_NOT = "NOT "
        const OP_AND = " AND "
        const OP_PRE_AND = "AND "

        let negateQueryComponent = (component) => 
            component.startsWith(OP_NOT) ? component.substring(OP_NOT.length) : OP_NOT + component;

        let queryComponent = `${field}:${escapeSearchValue(value)}`
        let queryValue = this.state.query;
        if(!queryValue) {
            queryValue = queryComponent;
        }
        else {
            if(field.startsWith(OP_NOT)){
                // Let ~negated query pass condition
                if (queryValue.includes(queryComponent)){}
                // Remove AND ~query
                else if(queryValue.includes(OP_AND + negateQueryComponent(queryComponent)))
                    queryValue = queryValue.replace(OP_AND + negateQueryComponent(queryComponent), "")
                // Remove ~query
                else if(queryValue.includes(negateQueryComponent(queryComponent)))
                    queryValue = queryValue.replace(negateQueryComponent(queryComponent), "")
                // Add ~query
                else
                    queryValue = queryValue + OP_AND + queryComponent
            }
            // Remove AND ~negated query
            else if(queryValue.includes(OP_AND + negateQueryComponent(queryComponent)))
                queryValue = queryValue.replace(OP_AND + negateQueryComponent(queryComponent), "")
            // Remove ~negated query
            else if(queryValue.includes(negateQueryComponent(queryComponent)))
                queryValue = queryValue.replace(negateQueryComponent(queryComponent), "")
            // Remove duplicated query
            else if(!queryValue.includes(queryComponent))
                queryValue = queryValue + OP_AND + queryComponent 
        }
        queryValue = queryValue.trim()
        if(queryValue.startsWith(OP_PRE_AND))
            queryValue = queryValue.substring(OP_PRE_AND.length)
        this.submitQuery(queryValue)
    }


    loadMoreItems(pageNumber) {
        // Prevent respawn on component update
        this.setState({hasMore: false, loadsMore: true}, async () => {
            try {
                let pivot = null;
                if(this.state.elements.length) {
                    pivot = this.state.elements[this.state.elements.length - 1].id
                }
                let response = await api.getObjectList(
                    this.props.type,
                    pivot,
                    this.state.currentQuery
                );
                let elements = response.data[this.props.type+"s"]
                this.setState({
                    elements: [...this.state.elements, ...elements],
                    hasMore: elements.length !== 0
                })
            } catch(error) {
                if(!error.response || error.response.status !== 404)
                    this.setState({error});
            } finally {
                this.setState({loadsMore: false});
            }
        });
    }

    render() {
        return (
            <View fluid ident={"RecentObjects"} error={this.state.error}>
                <div className="table-responsive">
                    <form className="searchForm" onSubmit={this.handleQuerySubmit}>
                        <div className="input-group">
                            <div className="input-group-prepend">
                                <input className="btn btn-outline-danger" type="button" value="X" onClick={this.handleQueryReset}/>
                            </div>
                            <input className="form-control small" type="text" placeholder="Search (Lucene query or hash)..." value={this.state.query}
                                onChange={this.updateQueryValue}/>
                            <div className="input-group-append">
                                <input className="btn btn-outline-success" type="submit" value="Search"/>
                                <Link to="/search_help" className="btn btn-outline-primary">?</Link>
                            </div>
                        </div>
                        <div className="input-group">
                            {this.state.queryError
                            ? <div className="form-hint">{this.state.queryError.response 
                                ? this.state.queryError.response.data["message"] 
                                : this.state.queryError.toString()}</div>
                            : []
                            }
                            <div className="form-hint">
                                Quick query:
                                <span className="badge badge-secondary" style={{"cursor": "pointer"}}
                                      onClick={(ev) => {ev.preventDefault(); this.addToQuery("uploader", this.props.userLogin)}}>
                                    Only uploaded by me
                                </span>
                                <span className="badge badge-secondary" style={{"cursor": "pointer"}}
                                      onClick={(ev) => {ev.preventDefault(); this.addToQuery("NOT shared", "public")}}>
                                    Exclude public
                                </span>
                                <span className="badge badge-primary" style={{"cursor": "pointer"}}
                                      onClick={(ev) => {ev.preventDefault(); this.addToQuery("NOT tag", "feed:*")}}>
                                    Exclude feed:*
                                </span>
                                <span className="badge badge-warning" style={{"cursor": "pointer"}}
                                      onClick={(ev) => {ev.preventDefault(); this.addToQuery("tag", "ripped:*")}}>
                                    Only ripped:*
                                </span>
                                <QuickQuery type ={this.props.type} query={this.state.query} submitQuery={this.submitQuery} updateQueryValue ={this.updateQueryValue} />
                            </div>
                        </div>
                    </form>
                    <table className="table table-striped table-bordered wrap-table"
                           style={this.state.lockView ? {pointerEvents: "none", filter: "blur(4px)"} : {}}>
                        <thead>
                            <tr>
                                {
                                    this.props.itemType.labels.map(f => <th key={f}>{f}</th>)
                                }
                            </tr>
                        </thead>
                        <InfiniteScroll
                            ref={(scroll) => { this.scroll = scroll; }}
                            pageStart={0}
                            loadMore={this.loadMoreItems.bind(this)}
                            hasMore={this.state.hasMore}
                            element={'tbody'}>
                            {
                                this.state.elements.map((item, idx) => <this.props.itemType key={idx} addToQuery={this.addToQuery} {...item}/>)
                            }
                            {
                                this.state.loadsMore ? <tr key={0}>
                                    <td colSpan={this.props.itemType.labels.length}>
                                        Loading...
                                    </td>
                                </tr> : []
                            }
                        </InfiniteScroll>
                    </table>
                </div>
            </View>
        );
    }
}

function mapStateToProps(state, ownProps)
{
    return {
        ...ownProps,
        userLogin: state.auth.loggedUser && state.auth.loggedUser.login
    }
}

export default connect(mapStateToProps)(RecentObjects);
